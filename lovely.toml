[manifest]
version = "1.0.0"
dump_lua = true
priority = 1

# Add Trick or Treak Functionality --------------------------------------

    # Apply modifier to pack choice
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "G.GAME.pack_choices = self.config.center.config.choose or 1"
position = "after"
payload = '''
G.GAME.pack_choices = G.GAME.pack_choices + G.GAME.choose_mod
'''
match_indent = true
times = 1


    # Add modifier to definitions
[[patches]]
[patches.regex]
target = "functions/common_events.lua"
pattern = "(cfg.choose)"
position = "after"
payload = " + G.GAME.choose_mod"
times = 15


    # Create modifier variable
[[patches]]
[patches.pattern]
target = "game.lua"
pattern = "pack_size = 2,"
position = "after"
payload = "choose_mod = 0,"
match_indent = true
times = 1






# Add Egg Explosion Functionality -----------------------------------------

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if self.ability.name == 'Egg' then
    self.ability.extra_value = self.ability.extra_value + self.ability.extra
    self:set_cost()
'''
position = "after"
payload = '''
if next(SMODS.find_card('j_mxms_microwave')) and pseudorandom('eggsplode', 1, 20) == 1 then
    G.E_MANAGER:add_event(Event({
        func = function()
            play_sound('mxms_eggsplosion')
            ease_dollars(self.sell_cost)
            self:start_dissolve({G.C.ORANGE}, nil, 1.6)
            return true;
        end
    }))
    return {
        message = 'Exploded...',
        colour = G.C.MONEY
    }
end
'''
match_indent = true
times = 1




# Add Faded Joker Functionality -----------------------------------------

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if next(find_joker('Smeared Joker')) and (self.base.suit == 'Hearts' or self.base.suit == 'Diamonds') == (suit == 'Hearts' or suit == 'Diamonds') then
    return true
end
'''
position = "after"
payload = '''
if next(SMODS.find_card('j_mxms_faded')) and (self.base.suit == 'Spades' or self.base.suit == 'Diamonds') == (suit == 'Spades' or suit == 'Diamonds') then
    return true
end
'''
match_indent = true
times = 2






# Add War Functionality -------------------------------------------------

    # Create modifier variable
[[patches]]
[patches.pattern]
target = "game.lua"
pattern = "pack_size = 2,"
position = "after"
payload = "war_mod = 1,"
match_indent = true
times = 1


    #Change limits and description for Trading Card
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "G.GAME.current_round.discards_used <= 0 and #context.full_hand == 1 then"
position = "at"
payload = "G.GAME.current_round.discards_used <= 0 and #context.full_hand == 1 * G.GAME.war_mod then"
match_indent = true
times = 1

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "elseif self.ability.name == 'Trading Card' then loc_vars = {self.ability.extra}"
position = "at"
payload = "elseif self.ability.name == 'Trading Card' then loc_vars = {self.ability.extra, self.ability.destroy * G.GAME.war_mod}"
match_indent = true
times = 1

[[patches]]
[patches.pattern]
target = "game.lua"
pattern = '''
j_trading=          {order = 95,   unlocked = true, discovered = false, blueprint_compat = false, perishable_compat = true, eternal_compat = true, rarity = 2, cost = 6, name = "Trading Card",set = "Joker", config = {extra = 3}, pos = {x=9,y=14}},
'''
position = "at"
payload = '''
j_trading=          {order = 95,   unlocked = true, discovered = false, blueprint_compat = false, perishable_compat = true, eternal_compat = true, rarity = 2, cost = 6, name = "Trading Card",set = "Joker", config = {extra = 3, destroy = 1}, pos = {x=9,y=14}},
'''
match_indent = true


    #Change limits and description for Sixth Sense (includes Perspective Functionality to reduce patches)
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "if self.ability.name == 'Sixth Sense' and #context.full_hand == 1 and context.full_hand[1]:get_id() == 6 and G.GAME.current_round.hands_played == 0 then"
position = "at"
payload = '''
    if self.ability.name == 'Sixth Sense' and #context.full_hand <= 1 * G.GAME.war_mod and G.GAME.current_round.hands_played == 0 then
        for i = 1, #context.full_hand do
            if not (context.full_hand[i]:get_id() == 6 or (next(SMODS.find_card('j_mxms_perspective')) and context.full_hand[1]:get_id() == 9)) then
                return
            end
        end
'''
match_indent = true
times = 1

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "elseif self.ability.name == 'Sixth Sense' then loc_vars = {}"
position = "at"
payload = "elseif self.ability.name == 'Sixth Sense' then loc_vars = {self.ability.destroy * G.GAME.war_mod}"
match_indent = true
times = 1

[[patches]]
[patches.pattern]
target = "game.lua"
pattern = '''
j_sixth_sense=      {order = 54,  unlocked = true,  discovered = false, blueprint_compat = false, perishable_compat = true, eternal_compat = true, rarity = 2, cost = 6, name = 'Sixth Sense', pos = {x = 8, y = 10}, set = 'Joker', config = {}},
'''
position = "at"
payload = '''
j_sixth_sense=      {order = 54,  unlocked = true,  discovered = false, blueprint_compat = false, perishable_compat = true, eternal_compat = true, rarity = 2, cost = 6, name = 'Sixth Sense', pos = {x = 8, y = 10}, set = 'Joker', config = {destroy = 1}},
'''
match_indent = true
times = 1


    #Change limits and description for Immolate
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "for i = 1, self.ability.extra.destroy do destroyed_cards[#destroyed_cards+1] = temp_hand[i] end"
position = "at"
payload = "for i = 1, self.ability.extra.destroy * G.GAME.war_mod do destroyed_cards[#destroyed_cards+1] = temp_hand[i] end"
match_indent = true
times = 1

[[patches]]
[patches.pattern]
target = "functions/common_events.lua"
pattern = "elseif _c.name == 'Immolate' then loc_vars = {cfg.extra.destroy, cfg.extra.dollars}"
position = "at"
payload = "elseif _c.name == 'Immolate' then loc_vars = {cfg.extra.destroy * G.GAME.war_mod, cfg.extra.dollars}"
match_indent = true
times = 1


    #Change limits and description for Hanged Man
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if self.ability.consumeable and self.ability.consumeable.max_highlighted then
    self.ability.consumeable.mod_num = math.min(5, self.ability.consumeable.max_highlighted)
end
'''
position = "at"
payload = '''
if self.ability.consumeable and self.ability.consumeable.max_highlighted then
    if self.ability.name == 'The Hanged Man' then
        self.ability.consumeable.mod_num = math.min(5, self.ability.consumeable.max_highlighted * G.GAME.war_mod)
    else
        self.ability.consumeable.mod_num = math.min(5, self.ability.consumeable.max_highlighted)
    end
end
'''
match_indent = true
times = 1

[[patches]]
[patches.pattern]
target = "functions/common_events.lua"
pattern = '''
elseif _c.name == "The Hanged Man" then loc_vars = {cfg.max_highlighted}
'''
position = "at"
payload = '''
elseif _c.name == "The Hanged Man" then loc_vars = {cfg.max_highlighted * G.GAME.war_mod}
'''
match_indent = true
times = 1


    #Change limits and descriptions for Grim, Incantation, and Familiar
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "destroyed_cards[#destroyed_cards+1] = pseudorandom_element(G.hand.cards, pseudoseed('random_destroy'))"
position = "at"
payload = '''
sendInfoMessage('Preparing to destroy cards','MaximusDebug')
local temp_hand = {}
for k, v in ipairs(G.hand.cards) do temp_hand[#temp_hand+1] = v end
table.sort(temp_hand, function (a, b) return not a.playing_card or not b.playing_card or a.playing_card < b.playing_card end)
pseudoshuffle(temp_hand, pseudoseed('random_destroy'))

for i = 1, self.ability.extra.destroy * G.GAME.war_mod do 
    destroyed_cards[#destroyed_cards+1] = temp_hand[i] 
    sendInfoMessage('Destroyed card from ' .. self.ability.name,'MaximusDebug')
end

'''
match_indent = true
times = 1

[[patches]]
[patches.pattern]
target = "game.lua"
pattern = '''
c_familiar=         {order = 1,    discovered = false, cost = 4, consumeable = true, name = "Familiar", pos = {x=0,y=4}, set = "Spectral", config = {remove_card = true, extra = 3}},
c_grim=             {order = 2,    discovered = false, cost = 4, consumeable = true, name = "Grim",     pos = {x=1,y=4}, set = "Spectral", config = {remove_card = true, extra = 2}},
c_incantation=      {order = 3,    discovered = false, cost = 4, consumeable = true, name = "Incantation", pos = {x=2,y=4}, set = "Spectral", config = {remove_card = true, extra = 4}},
'''
position = "at"
payload = '''
c_familiar=         {order = 1,    discovered = false, cost = 4, consumeable = true, name = "Familiar", pos = {x=0,y=4}, set = "Spectral", config = {remove_card = true, extra = 3, destroy = 1}},
c_grim=             {order = 2,    discovered = false, cost = 4, consumeable = true, name = "Grim",     pos = {x=1,y=4}, set = "Spectral", config = {remove_card = true, extra = 2, destroy = 1}},
c_incantation=      {order = 3,    discovered = false, cost = 4, consumeable = true, name = "Incantation", pos = {x=2,y=4}, set = "Spectral", config = {remove_card = true, extra = 4, destroy = 1}},
'''
match_indent = true
times = 1

[[patches]]
[patches.pattern]
target = "functions/common_events.lua"
pattern = "if _c.name == 'Familiar' or _c.name == 'Grim' or _c.name == 'Incantation' then loc_vars = {cfg.extra}"
position = "at"
payload = "if _c.name == 'Familiar' or _c.name == 'Grim' or _c.name == 'Incantation' then loc_vars = {cfg.extra, cfg.destroy * G.GAME.war_mod}"
match_indent = true
times = 1







# Add Perspective Functionality -----------------------------------------

    #Mail-in Rebate flag
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if self.ability.name == 'Mail-In Rebate' and
not context.other_card.debuff and
context.other_card:get_id() == G.GAME.current_round.mail_card.id then
    ease_dollars(self.ability.extra)
    return {
        message = localize('$')..self.ability.extra,
        colour = G.C.MONEY,
        card = self
    }
end
'''
position = "at"
payload = '''
if self.ability.name == 'Mail-In Rebate' and
not context.other_card.debuff then
    if context.other_card:get_id() == G.GAME.current_round.mail_card.id 
    or (next(SMODS.find_card('j_mxms_perspective')) and 
    ((context.other_card:get_id() == 9 and G.GAME.current_round.mail_card.id == 6) 
    or (context.other_card:get_id() == 6 and G.GAME.current_round.mail_card.id == 9))) then
        ease_dollars(self.ability.extra)
        return {
            message = localize('$')..self.ability.extra,
            colour = G.C.MONEY,
            card = self
        }
    end
end
'''
match_indent = true
times = 1


    #The Idol flag
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if self.ability.name == 'The Idol' and
    context.other_card:get_id() == G.GAME.current_round.idol_card.id and 
    context.other_card:is_suit(G.GAME.current_round.idol_card.suit) then
        return {
            x_mult = self.ability.extra,
            colour = G.C.RED,
            card = self
        }
    end
'''
position = "at"
payload = '''
if self.ability.name == 'The Idol' then
    if context.other_card:get_id() == G.GAME.current_round.idol_card.id
    or (next(SMODS.find_card('j_mxms_perspective')) and 
    ((context.other_card:get_id() == 9 and G.GAME.current_round.idol_card.id == 6) 
    or (context.other_card:get_id() == 6 and G.GAME.current_round.idol_card.id == 9))) 
    and context.other_card:is_suit(G.GAME.current_round.idol_card.suit) then
        return {
            x_mult = self.ability.extra,
            colour = G.C.RED,
            card = self
        }
    end
end
'''
match_indent = true
times = 1


    #Even Steven flag
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if self.ability.name == 'Even Steven' and
context.other_card:get_id() <= 10 and 
context.other_card:get_id() >= 0 and
context.other_card:get_id()%2 == 0
then
'''
position = "at"
payload = '''
if self.ability.name == 'Even Steven' and
((context.other_card:get_id() <= 10 and 
context.other_card:get_id() >= 0 and
context.other_card:get_id()%2 == 0) or
(next(SMODS.find_card('j_mxms_perspective')) and context.other_card:get_id() == 9))
then
'''
match_indent = true
times = 1


    #Odd Todd flag
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if self.ability.name == 'Odd Todd' and
((context.other_card:get_id() <= 10 and 
context.other_card:get_id() >= 0 and
context.other_card:get_id()%2 == 1) or
(context.other_card:get_id() == 14))
then
'''
position = "at"
payload = '''
if self.ability.name == 'Odd Todd' and
(((context.other_card:get_id() <= 10 and 
context.other_card:get_id() >= 0 and
context.other_card:get_id()%2 == 1) or
(context.other_card:get_id() == 14)) or
(next(SMODS.find_card('j_mxms_perspective')) and context.other_card:get_id() == 6))
then
'''
match_indent = true
times = 1


    #Cloud 9 flag
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if v:get_id() == 9 then self.ability.nine_tally = self.ability.nine_tally+1 end
'''
position = "at"
payload = '''
if v:get_id() == 9 or (next(SMODS.find_card('j_mxms_perspective')) and v:get_id() == 6) then self.ability.nine_tally = self.ability.nine_tally+1 end
'''
match_indent = true
times = 1






# Set up Leftovers flags ------------------------------------------------

    #Create flag variable
[[patches]]
[patches.pattern]
target = "game.lua"
pattern = "pack_size = 2,"
position = "after"
payload = "destroyed_food = '',"
match_indent = true
times = 1


    #Gros Michel/Cavendish flag
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "if pseudorandom(self.ability.name == 'Cavendish' and 'cavendish' or 'gros_michel') < G.GAME.probabilities.normal/self.ability.extra.odds then "
position = "after"
payload = '''
if next(SMODS.find_card('j_mxms_leftovers')) then
    G.GAME.destroyed_food = self.config.center.key
end
'''
match_indent = true
times = 1


    #Ramen flag
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
 if self.ability.name == 'Ramen' and not context.blueprint then
    if self.ability.x_mult - self.ability.extra <= 1 then
'''
position = "after"
payload = '''
if next(SMODS.find_card('j_mxms_leftovers')) then
    G.GAME.destroyed_food = self.config.center.key
end
'''
match_indent = true
times = 1


    #Ice Cream flag
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if self.ability.name == 'Ice Cream' and not context.blueprint then
    if self.ability.extra.chips - self.ability.extra.chip_mod <= 0 then
'''
position = "after"
payload = '''
if next(SMODS.find_card('j_mxms_leftovers')) then
    G.GAME.destroyed_food = self.config.center.key
end
'''
match_indent = true
times = 1


    #Turtle Bean flag
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if self.ability.name == 'Turtle Bean' and not context.blueprint then
    if self.ability.extra.h_size - self.ability.extra.h_mod <= 0 then 
'''
position = "after"
payload = '''
if next(SMODS.find_card('j_mxms_leftovers')) then
    G.GAME.destroyed_food = self.config.center.key
end
'''
match_indent = true
times = 1


    #Diet Cola flag
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if self.ability.name == 'Diet Cola' then
'''
position = "after"
payload = '''
if next(SMODS.find_card('j_mxms_leftovers')) then
    G.GAME.destroyed_food = self.config.center.key
end
'''
match_indent = true
times = 1


    #Popcorn flag
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if self.ability.name == 'Popcorn' and not context.blueprint then
    if self.ability.mult - self.ability.extra <= 0 then 
'''
position = "after"
payload = '''
if next(SMODS.find_card('j_mxms_leftovers')) then
    G.GAME.destroyed_food = self.config.center.key
end
'''
match_indent = true
times = 1


    #Seltzer flag
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if self.ability.name == 'Seltzer' and not context.blueprint then
    if self.ability.extra - 1 <= 0 then 
'''
position = "after"
payload = '''
if next(SMODS.find_card('j_mxms_leftovers')) then
    G.GAME.destroyed_food = self.config.center.key
end
'''
match_indent = true
times = 1


    #Egg flag
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
elseif context.selling_self then
'''
position = "after"
payload = '''
if self.ability.name == 'Egg' then
    if next(SMODS.find_card('j_mxms_leftovers')) then
        G.GAME.destroyed_food = self.config.center.key
    end
end
'''
match_indent = true
times = 1






# Add Pessimistic Functionality ----------------------------------------

    # Add flag to Wheel of Fortune
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()
    attention_text({
        text = localize('k_nope_ex'),
'''
position = "before"
payload = '''
if next(SMODS.find_card('j_mxms_pessimistic')) then
    for k, v in pairs(G.jokers.cards) do
        if v.config.center.key == 'j_mxms_pessimistic' then
            v.ability.extra.mult = v.ability.extra.mult + (self.ability.extra - G.GAME.probabilities.normal)
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                func = function()
                    v:juice_up(0.3, 0.4)
                return true; end
            }))
            
        end
    end
end
'''
match_indent = true
times = 1


    # Add flag to Hallucination
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if pseudorandom('halu'..G.GAME.round_resets.ante) < G.GAME.probabilities.normal/self.ability.extra then
    G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1
    G.E_MANAGER:add_event(Event({
        trigger = 'before',
        delay = 0.0,
        func = (function()
            local card = create_card('Tarot',G.consumeables, nil, nil, nil, nil, nil, 'hal')
            card:add_to_deck()
                G.consumeables:emplace(card)
                G.GAME.consumeable_buffer = 0
            return true
        end)}))
    card_eval_status_text(self, 'extra', nil, nil, nil, {message = localize('k_plus_tarot'), colour = G.C.PURPLE})
'''
position = "after"
payload = '''
elseif next(SMODS.find_card('j_mxms_pessimistic')) then
    for k, v in pairs(G.jokers.cards) do
        if v.config.center.key == 'j_mxms_pessimistic' then
            v.ability.extra.mult = v.ability.extra.mult + (self.ability.extra - G.GAME.probabilities.normal)
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                func = function()
                    v:juice_up(0.3, 0.4)
                return true; end
            }))
        end
    end
'''
match_indent = true
times = 1


    # Add flag to Gros Michel/Cavendish (Includes fridge_mod so gain scales based on Refrigerator joker)
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if pseudorandom(self.ability.name == 'Cavendish' and 'cavendish' or 'gros_michel') < G.GAME.probabilities.normal/self.ability.extra.odds then 
'''
position = "after"
payload = '''
if next(SMODS.find_card('j_mxms_pessimistic')) then
    for k, v in pairs(G.jokers.cards) do
        if v.config.center.key == 'j_mxms_pessimistic' then
            v.ability.extra.mult = v.ability.extra.mult + (self.ability.extra - G.GAME.probabilities.normal)
            G.E_MANAGER:add_event(Event({
                trigger = 'after',
                func = function()
                    v:juice_up(0.3, 0.4)
                return true; end
            }))
        end
    end
end
'''
match_indent = true
times = 1


    # Add flag to 8 Ball
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if (context.other_card:get_id() == 8) and (pseudorandom('8ball') < G.GAME.probabilities.normal/self.ability.extra) then
    G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1
    return {
        extra = {focus = self, message = localize('k_plus_tarot'), func = function()
            G.E_MANAGER:add_event(Event({
                trigger = 'before',
                delay = 0.0,
                func = (function()
                        local card = create_card('Tarot',G.consumeables, nil, nil, nil, nil, nil, '8ba')
                        card:add_to_deck()
                        G.consumeables:emplace(card)
                        G.GAME.consumeable_buffer = 0
                    return true
                end)}))
        end},
        colour = G.C.SECONDARY_SET.Tarot,
        card = self
    }
end
'''
position = "at"
payload = '''
if (context.other_card:get_id() == 8) then
    if (pseudorandom('8ball') < G.GAME.probabilities.normal/self.ability.extra) then
        G.GAME.consumeable_buffer = G.GAME.consumeable_buffer + 1
        return {
            extra = {focus = self, message = localize('k_plus_tarot'), func = function()
                G.E_MANAGER:add_event(Event({
                    trigger = 'before',
                    delay = 0.0,
                    func = (function()
                        local card = create_card('Tarot',G.consumeables, nil, nil, nil, nil, nil, '8ba')
                        card:add_to_deck()
                        G.consumeables:emplace(card)
                        G.GAME.consumeable_buffer = 0
                    return true
                end)}))
            end},
            colour = G.C.SECONDARY_SET.Tarot,
            card = self
        }
    elseif next(SMODS.find_card('j_mxms_pessimistic')) then
        for k, v in pairs(G.jokers.cards) do
            if v.config.center.key == 'j_mxms_pessimistic' then
                v.ability.extra.mult = v.ability.extra.mult + (self.ability.extra - G.GAME.probabilities.normal)
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    func = function()
                        v:juice_up(0.3, 0.4)
                    return true; end
                }))
            end
        end
    end
end
'''
match_indent = true
times = 1


    # Add flag to Business Card
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if self.ability.name == 'Business Card' and
    context.other_card:is_face() and
    pseudorandom('business') < G.GAME.probabilities.normal/self.ability.extra then
        G.GAME.dollar_buffer = (G.GAME.dollar_buffer or 0) + 2
        G.E_MANAGER:add_event(Event({func = (function() G.GAME.dollar_buffer = 0; return true end)}))
        return {
            dollars = 2,
            card = self
        }
    end
'''
position = "at"
payload = '''
if self.ability.name == 'Business Card' and
context.other_card:is_face() then
    if pseudorandom('business') < G.GAME.probabilities.normal/self.ability.extra then
        G.GAME.dollar_buffer = (G.GAME.dollar_buffer or 0) + 2
        G.E_MANAGER:add_event(Event({func = (function() G.GAME.dollar_buffer = 0; return true end)}))
        return {
            dollars = 2,
            card = self
        }
    elseif next(SMODS.find_card('j_mxms_pessimistic')) then
        for k, v in pairs(G.jokers.cards) do
            if v.config.center.key == 'j_mxms_pessimistic' then
                v.ability.extra.mult = v.ability.extra.mult + (self.ability.extra - G.GAME.probabilities.normal)
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    func = function()
                        v:juice_up(0.3, 0.4)
                    return true; end
                }))
            end
        end
    end
end
'''
match_indent = true
times = 1


    # Add flag to Bloodstone
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if self.ability.name ==  'Bloodstone' and
context.other_card:is_suit("Hearts") and 
pseudorandom('bloodstone') < G.GAME.probabilities.normal/self.ability.extra.odds then
    return {
        x_mult = self.ability.extra.Xmult,
        card = self
    }
end
'''
position = "at"
payload = '''
if self.ability.name ==  'Bloodstone' and
context.other_card:is_suit("Hearts") then 
    if pseudorandom('bloodstone') < G.GAME.probabilities.normal/self.ability.extra.odds then
        return {
            x_mult = self.ability.extra.Xmult,
            card = self
        }
    elseif next(SMODS.find_card('j_mxms_pessimistic')) then
        for k, v in pairs(G.jokers.cards) do
            if v.config.center.key == 'j_mxms_pessimistic' then
                v.ability.extra.mult = v.ability.extra.mult + (self.ability.extra - G.GAME.probabilities.normal)
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    func = function()
                        v:juice_up(0.3, 0.4)
                    return true; end
                }))
            end
        end
    end
end
'''
match_indent = true
times = 1


    # Add flag to Reserved Parking
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if self.ability.name == 'Reserved Parking' and
context.other_card:is_face() and
pseudorandom('parking') < G.GAME.probabilities.normal/self.ability.extra.odds then
    if context.other_card.debuff then
        return {
            message = localize('k_debuffed'),
            colour = G.C.RED,
            card = self,
        }
    else
        G.GAME.dollar_buffer = (G.GAME.dollar_buffer or 0) + self.ability.extra.dollars
        G.E_MANAGER:add_event(Event({func = (function() G.GAME.dollar_buffer = 0; return true end)}))
        return {
            dollars = self.ability.extra.dollars,
            card = self
        }
    end
end
'''
position = "at"
payload = '''
if self.ability.name == 'Reserved Parking' and
context.other_card:is_face() then
    if pseudorandom('parking') < G.GAME.probabilities.normal/self.ability.extra.odds then
        if context.other_card.debuff then
            return {
                message = localize('k_debuffed'),
                colour = G.C.RED,
                card = self,
            }
        else
            G.GAME.dollar_buffer = (G.GAME.dollar_buffer or 0) + self.ability.extra.dollars
            G.E_MANAGER:add_event(Event({func = (function() G.GAME.dollar_buffer = 0; return true end)}))
            return {
                dollars = self.ability.extra.dollars,
                card = self
            }
        end
    elseif next(SMODS.find_card('j_mxms_pessimistic')) then
        for k, v in pairs(G.jokers.cards) do
            if v.config.center.key == 'j_mxms_pessimistic' then
                v.ability.extra.mult = v.ability.extra.mult + (self.ability.extra - G.GAME.probabilities.normal)
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    func = function()
                        v:juice_up(0.3, 0.4)
                    return true; end
                }))
            end
        end
    end
end
'''
match_indent = true
times = 1


    # Add flag to Space Joker
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if self.ability.name == 'Space Joker' and pseudorandom('space') < G.GAME.probabilities.normal/self.ability.extra then
    return {
        card = self,
        level_up = true,
        message = localize('k_level_up_ex')
    }
end
'''
position = "at"
payload = '''
if self.ability.name == 'Space Joker' then
    if pseudorandom('space') < G.GAME.probabilities.normal/self.ability.extra then
        return {
            card = self,
            level_up = true,
            message = localize('k_level_up_ex')
        }
    elseif next(SMODS.find_card('j_mxms_pessimistic')) then
        for k, v in pairs(G.jokers.cards) do
            if v.config.center.key == 'j_mxms_pessimistic' then
                v.ability.extra.mult = v.ability.extra.mult + (self.ability.extra - G.GAME.probabilities.normal)
                G.E_MANAGER:add_event(Event({
                    trigger = 'after',
                    func = function()
                        v:juice_up(0.3, 0.4)
                    return true; end
                }))
            end
        end
    end
end
'''
match_indent = true
times = 1






# Refrigerator Functionality --------------------------------------

    # Create modifier variable
[[patches]]
[patches.pattern]
target = "game.lua"
pattern = "pack_size = 2,"
position = "after"
payload = "fridge_mod = 1,"
match_indent = true
times = 1


    # Add modifier to Gros Michel/Cavendish
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "elseif self.ability.name == 'Gros Michel' then loc_vars = {self.ability.extra.mult, ''..(G.GAME and G.GAME.probabilities.normal or 1), self.ability.extra.odds}"
position = "at"
payload = "elseif self.ability.name == 'Gros Michel' then loc_vars = {self.ability.extra.mult, ''..(G.GAME and G.GAME.probabilities.normal or 1), self.ability.extra.odds * G.GAME.fridge_mod}"
match_indent = true
times = 1

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "elseif self.ability.name == 'Cavendish' then loc_vars = {self.ability.extra.Xmult, ''..(G.GAME and G.GAME.probabilities.normal or 1), self.ability.extra.odds}"
position = "at"
payload = "elseif self.ability.name == 'Cavendish' then loc_vars = {self.ability.extra.Xmult, ''..(G.GAME and G.GAME.probabilities.normal or 1), self.ability.extra.odds * G.GAME.fridge_mod}"
match_indent = true
times = 1


    # Add modifier to Ice Cream
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "elseif self.ability.name == 'Ice Cream' then loc_vars = {self.ability.extra.chips, self.ability.extra.chip_mod}"
position = "at"
payload = "elseif self.ability.name == 'Ice Cream' then loc_vars = {self.ability.extra.chips, self.ability.extra.chip_mod / G.GAME.fridge_mod}"
match_indent = true
times = 1

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "if self.ability.extra.chips - self.ability.extra.chip_mod <= 0 then "
position = "at"
payload = "if self.ability.extra.chips - (self.ability.extra.chip_mod / G.GAME.fridge_mod) <= 0 then"
match_indent = true
times = 1

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "self.ability.extra.chips = self.ability.extra.chips - self.ability.extra.chip_mod"
position = "at"
payload = "self.ability.extra.chips = self.ability.extra.chips - (self.ability.extra.chip_mod / G.GAME.fridge_mod)"
match_indent = true
times = 1

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "message = localize{type='variable',key='a_chips_minus',vars={self.ability.extra.chip_mod}},"
position = "at"
payload = "message = localize{type='variable',key='a_chips_minus',vars={self.ability.extra.chip_mod / G.GAME.fridge_mod}},"
match_indent = true
times = 1




    # Add modifier to Turtle Bean
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "elseif self.ability.name == 'Turtle Bean' then loc_vars = {self.ability.extra.h_size, self.ability.extra.h_mod}"
position = "at"
payload = "elseif self.ability.name == 'Turtle Bean' then loc_vars = {self.ability.extra.h_size, self.ability.extra.h_mod / G.GAME.fridge_mod}"
match_indent = true
times = 1

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "if self.ability.extra.h_size - self.ability.extra.h_mod <= 0 then"
position = "at"
payload = "if self.ability.extra.h_size - (self.ability.extra.h_mod / G.GAME.fridge_mod) <= 0 then"
match_indent = true
times = 1

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "G.hand:change_size(- self.ability.extra.h_mod)"
position = "at"
payload = "G.hand:change_size(- (self.ability.extra.h_mod / G.GAME.fridge_mod))"
match_indent = true
times = 1

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "message = localize{type='variable',key='a_handsize_minus',vars={self.ability.extra.h_mod}},"
position = "at"
payload = "message = localize{type='variable',key='a_handsize_minus',vars={self.ability.extra.h_mod / G.GAME.fridge_mod}},"
match_indent = true
times = 1


    # Add modifier to Popcorn
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "elseif self.ability.name == 'Popcorn' then loc_vars = {self.ability.mult, self.ability.extra}"
position = "at"
payload = "elseif self.ability.name == 'Popcorn' then loc_vars = {self.ability.mult, self.ability.extra / G.GAME.fridge_mod}"
match_indent = true
times = 1

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "if self.ability.mult - self.ability.extra <= 0 then"
position = "at"
payload = "if self.ability.mult - (self.ability.extra / G.GAME.fridge_mod) <= 0 then "
match_indent = true
times = 1

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "self.ability.mult = self.ability.mult - self.ability.extra"
position = "at"
payload = "self.ability.mult = self.ability.mult - (self.ability.extra / G.GAME.fridge_mod)"
match_indent = true
times = 1

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "message = localize{type='variable',key='a_mult_minus',vars={self.ability.extra}},"
position = "at"
payload = "message = localize{type='variable',key='a_mult_minus',vars={self.ability.extra / G.GAME.fridge_mod}},"
match_indent = true
times = 1


    # Add modifier to Ramen
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "elseif self.ability.name == 'Ramen' then loc_vars = {self.ability.x_mult, self.ability.extra}"
position = "at"
payload = "elseif self.ability.name == 'Ramen' then loc_vars = {self.ability.x_mult, self.ability.extra / G.GAME.fridge_mod}"
match_indent = true
times = 1

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "if self.ability.x_mult - self.ability.extra <= 1 then"
position = "at"
payload = "if self.ability.x_mult - (self.ability.extra / G.GAME.fridge_mod) <= 1 then"
match_indent = true
times = 1

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "self.ability.x_mult = self.ability.x_mult - self.ability.extra"
position = "at"
payload = "self.ability.x_mult = self.ability.x_mult - (self.ability.extra / G.GAME.fridge_mod)"
match_indent = true
times = 1

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "message = localize{type='variable',key='a_xmult_minus',vars={self.ability.extra}},"
position = "at"
payload = "message = localize{type='variable',key='a_xmult_minus',vars={self.ability.extra / G.GAME.fridge_mod}},"
match_indent = true
times = 1


    # Add modifier to Seltzer
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "elseif self.ability.name == 'Seltzer' then loc_vars = {self.ability.extra}"
position = "at"
payload = "elseif self.ability.name == 'Seltzer' then loc_vars = {self.ability.extra * G.GAME.fridge_mod}"
match_indent = true
times = 1

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "if self.ability.extra - 1 <= 0 then "
position = "at"
payload = "if self.ability.extra - (1 / G.GAME.fridge_mod) <= 0 then "
match_indent = true
times = 1

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "self.ability.extra = self.ability.extra - 1"
position = "at"
payload = "self.ability.extra = self.ability.extra - (1 / G.GAME.fridge_mod)"
match_indent = true
times = 1

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "message = self.ability.extra..'',"
position = "at"
payload = "message = self.ability.extra * G.GAME.fridge_mod..'',"
match_indent = true
times = 1







# Hopscotch Functionality --------------------------------------

    # Create tracking variable
[[patches]]
[patches.pattern]
target = "game.lua"
pattern = "pack_size = 2,"
position = "after"
payload = "skip_tag = '',"
match_indent = true
times = 1


    # Intercept skip tag from 
[[patches]]
[patches.pattern]
target = "functions/button_callbacks.lua"
pattern = "if G.blind_select then "
position = "after"
payload = '''
    local _tag = e.UIBox:get_UIE_by_ID('tag_container')
    G.GAME.skip_tag = _tag
'''
match_indent = true
times = 2





# Secret Society Functionality ------------------------------------

    # Rewrite card scoring functionality (includes Hammer and Chisel implementation to reduce patches)
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if self.ability.effect == 'Stone Card' or self.config.center.replace_base_card then
    return self.ability.bonus + (self.ability.perma_bonus or 0)
end
'''
position = "at"
payload = '''
if self.ability.effect == 'Stone Card' and not next(SMODS.find_card('j_mxms_hammer_and_chisel')) then
    return self.ability.bonus + (self.ability.perma_bonus or 0)
elseif next(SMODS.find_card('j_mxms_secret_society')) then
    if self:get_id() == 2 then
        return 22 + self.ability.bonus + (self.ability.perma_bonus or 0)
    end
    if self:get_id() == 3 then
        return 20 + self.ability.bonus + (self.ability.perma_bonus or 0)
    end
    if self:get_id() == 4 then
        return 18 + self.ability.bonus + (self.ability.perma_bonus or 0)
    end
    if self:get_id() == 5 then
        return 16 + self.ability.bonus + (self.ability.perma_bonus or 0)
    end
    if self:get_id() == 6 then
        return 14 + self.ability.bonus + (self.ability.perma_bonus or 0)
    end
    if self:get_id() == 7 then
        return 12 + self.ability.bonus + (self.ability.perma_bonus or 0)
    end
    if self:get_id() == 8 then
        return 10 + self.ability.bonus + (self.ability.perma_bonus or 0)
    end
    if self:get_id() == 9 then
        return 8 + self.ability.bonus + (self.ability.perma_bonus or 0)
    end
    if self:get_id() == 10 or self:is_face() then
        return 6 + self.ability.bonus + (self.ability.perma_bonus or 0)
    end
    if self:get_id() == 14 then
        return 4 + self.ability.bonus + (self.ability.perma_bonus or 0)
    end
end
'''
match_indent = true
times = 1





# Hammer and Chisel Functionality ------------------------------------

    # Change stone card checks
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if flush_calc then
    if SMODS.has_no_suit(self) then
'''
position = "at"
payload = '''
if flush_calc then
    if SMODS.has_no_suit(self) and not next(SMODS.find_card('j_mxms_hammer_and_chisel')) then
'''
match_indent = true
times = 1

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
else
    if self.debuff and not bypass_debuff then return end
    if SMODS.has_no_suit(self) then
'''
position = "at"
payload = '''
else
    if self.debuff and not bypass_debuff then return end
    if SMODS.has_no_suit(self) and not next(SMODS.find_card('j_mxms_hammer_and_chisel')) then
'''
match_indent = true
times = 1

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "if self.ability.effect == 'Stone Card' or (self.config.center.no_suit and self.config.center.no_rank) then"
position = "at"
payload ="if (self.ability.effect == 'Stone Card' or (self.config.center.no_suit and self.config.center.no_rank)) and not next(SMODS.find_card('j_mxms_hammer_and_chisel')) then"
match_indent = true
times = 1

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if SMODS.has_no_rank(self) and not self.vampired then
    return -math.random(100, 1000000)
end
'''
position = "at"
payload = '''
if SMODS.has_no_rank(self) and not next(SMODS.find_card('j_mxms_hammer_and_chisel')) and not self.vampired then
    return -math.random(100, 1000000)
end
'''
match_indent = true
times = 1


    # Change Raise Fist interaction
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if temp_ID >= G.hand.cards[i].base.id and not SMODS.has_no_rank(G.hand.cards[i]) then 
'''
position = "at"
payload = '''
if temp_ID >= (G.hand.cards[i].base.id and not SMODS.has_no_rank(G.hand.cards[i])) or next(SMODS.find_card('j_mxms_hammer_and_chisel')) then
'''
match_indent = true
times = 1


    # Change rendering code for stone cards to include rank and suit
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
--If the card has a front, draw that next
if self.children.front and self.ability.effect ~= 'Stone Card' and not self.config.center.replace_base_card then
'''
position = "at"
payload = '''
--If the card has a front, draw that next
if self.children.front and (self.ability.effect ~= 'Stone Card' or next(SMODS.find_card('j_mxms_hammer_and_chisel'))) and not self.config.center.replace_base_card then
'''
match_indent = true
times = 1






# Add Soyjoke Functionality -----------------------------------------

    # Create modifier and tracker variables
[[patches]]
[patches.pattern]
target = "game.lua"
pattern = "pack_size = 2,"
position = "after"
payload = '''
soy_mod = 1,
purchased_jokers = {},
'''
match_indent = true
times = 1


    # Add joker to tracker or iterate modifier if already present (Clown Car functionality included)
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if self.ability.d_size > 0 then
    G.GAME.round_resets.discards = G.GAME.round_resets.discards + self.ability.d_size
    ease_discard(self.ability.d_size)
 end
'''
position = "after"
payload = '''
if self.ability.set == 'Joker' then
    G.GAME.current_round.jokers_purchased = G.GAME.current_round.jokers_purchased + 1
    if next(SMODS.find_card('j_mxms_clown_car')) then
        G.E_MANAGER:add_event(Event({func = function()
            for k, v in pairs(G.jokers.cards) do
                if v.config.center.key == 'j_mxms_clown_car' then
                    v.ability.extra.mult = v.ability.extra.mult + 8
                    return true
                end
            end
            G.GAME.purchased_jokers[#G.GAME.purchased_jokers + 1] = self.ability.name
        return true end }))
    end
    G.E_MANAGER:add_event(Event({func = function()
        for k, v in pairs(G.GAME.purchased_jokers) do
            if v == self.ability.name then
                G.GAME.soy_mod = G.GAME.soy_mod + 1
                return true
            end
        end
        G.GAME.purchased_jokers[#G.GAME.purchased_jokers + 1] = self.ability.name
    return true end }))
end
'''
match_indent = true
times = 1






# Add Gambler Functionality -----------------------------------------

    # Create modifier variable
[[patches]]
[patches.pattern]
target = "game.lua"
pattern = "pack_size = 2,"
position = "after"
payload = "gambler_mod = 1,"
match_indent = true
times = 1


    # Apply modifier to Hermit
[[patches]]
[patches.pattern]
target = "functions/common_events.lua"
pattern = '''
elseif _c.name == "The Hermit" then loc_vars = {cfg.extra}
'''
position = "at"
payload = '''
elseif _c.name == "The Hermit" then loc_vars = {(cfg.extra * G.GAME.gambler_mod)}
'''
match_indent = true
times = 1

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if self.ability.name == 'The Hermit' then
    G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()
        play_sound('timpani')
        used_tarot:juice_up(0.3, 0.5)
        ease_dollars(math.max(0,math.min(G.GAME.dollars, self.ability.extra)), true)
        return true end }))
    delay(0.6)
end
'''
position = "at"
payload = '''
if self.ability.name == 'The Hermit' then
    G.E_MANAGER:add_event(Event({trigger = 'after', delay = 0.4, func = function()
        play_sound('timpani')
        used_tarot:juice_up(0.3, 0.5)
        ease_dollars(math.max(0,math.min(G.GAME.dollars, self.ability.extra * G.GAME.gambler_mod)), true)
        return true end }))
    delay(0.6)
end
'''
match_indent = true
times = 1


    # Apply modifier to Temperance
[[patches]]
[patches.pattern]
target = "functions/common_events.lua"
pattern = '''
elseif _c.name == "Temperance" then
    local _money = 0
    if G.jokers then
        for i = 1, #G.jokers.cards do
            if G.jokers.cards[i].ability.set == 'Joker' then
                _money = _money + G.jokers.cards[i].sell_cost
            end
        end
    end
    loc_vars = {cfg.extra, math.min(cfg.extra, _money)}
'''
position = "at"
payload = '''
elseif _c.name == "Temperance" then
    local _money = 0
    if G.jokers then
        for i = 1, #G.jokers.cards do
            if G.jokers.cards[i].ability.set == 'Joker' then
                _money = _money + G.jokers.cards[i].sell_cost
            end
        end
    end
    loc_vars = {(cfg.extra * G.GAME.gambler_mod), math.min((cfg.extra * G.GAME.gambler_mod), _money)}
'''
match_indent = true
times = 1

[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if self.ability.name == 'Temperance' then
    self.ability.money = 0
    for i = 1, #G.jokers.cards do
        if G.jokers.cards[i].ability.set == 'Joker' then
            self.ability.money = self.ability.money + G.jokers.cards[i].sell_cost
        end
    end
    self.ability.money = math.min(self.ability.money, self.ability.extra)
end
'''
position = "at"
payload = '''
if self.ability.name == 'Temperance' then
    self.ability.money = 0
    for i = 1, #G.jokers.cards do
        if G.jokers.cards[i].ability.set == 'Joker' then
            self.ability.money = self.ability.money + G.jokers.cards[i].sell_cost
        end
    end
    self.ability.money = math.min(self.ability.money, self.ability.extra * G.GAME.gambler_mod)
end
'''
match_indent = true
times = 1


    # Apply modifier to Economy Tag
[[patches]]
[patches.pattern]
target = "tag.lua"
pattern = '''
elseif name_to_check == 'Economy Tag' then loc_vars = {self.config.max}
'''
position = "at"
payload = '''
elseif name_to_check == 'Economy Tag' then loc_vars = {self.config.max * G.GAME.gambler_mod}
'''
match_indent = true
times = 1






# Add Random Encounter Functionality -----------------------------------------

    # Create card variable
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = "perma_bonus = self.ability and self.ability.perma_bonus or 0,"
position = "after"
payload = "mult_perma_bonus = self.ability and self.ability.mult_perma_bonus or 0,"
match_indent = true
times = 1


    # Apply variable to mult calc
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
function Card:get_chip_mult()
    if self.debuff then return 0 end
    if self.ability.set == 'Joker' then return 0 end
    if self.ability.effect == "Lucky Card" then 
        if pseudorandom('lucky_mult') < G.GAME.probabilities.normal/5 then
            self.lucky_trigger = true
            return self.ability.mult
        else
            return 0
        end
    else  
        return self.ability.mult
    end
end
'''
position = "at"
payload = '''
function Card:get_chip_mult()
    if self.debuff then return 0 end
    if self.ability.set == 'Joker' then return 0 end
    if self.ability.effect == "Lucky Card" then 
        if pseudorandom('lucky_mult') < G.GAME.probabilities.normal/5 then
            self.lucky_trigger = true
            return self.ability.mult + self.ability.mult_perma_bonus
        else
            return 0
        end
    else  
        return self.ability.mult + self.ability.mult_perma_bonus
    end
end'''
match_indent = true
times = 1


    # Add variable to card description
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
loc_vars = { playing_card = not not self.base.colour, value = self.base.value, suit = self.base.suit, colour = self.base.colour,
    nominal_chips = self.base.nominal > 0 and self.base.nominal or nil,
    bonus_chips = (self.ability.bonus + (self.ability.perma_bonus or 0)) > 0 and (self.ability.bonus + (self.ability.perma_bonus or 0)) or nil,
}
'''
position = "at"
payload = '''
loc_vars = { playing_card = not not self.base.colour, value = self.base.value, suit = self.base.suit, colour = self.base.colour,
    nominal_chips = self.base.nominal > 0 and self.base.nominal or nil,
    bonus_chips = (self.ability.bonus + (self.ability.perma_bonus or 0)) > 0 and (self.ability.bonus + (self.ability.perma_bonus or 0)) or nil,
    bonus_mult = (self.ability.mult_perma_bonus > 0 and self.ability.mult_perma_bonus) or nil
}
'''
match_indent = true
times = 1

[[patches]]
[patches.pattern]
target = "functions/common_events.lua"
pattern = '''
if specific_vars.bonus_chips then
    localize{type = 'other', key = 'card_extra_chips', nodes = desc_nodes, vars = {specific_vars.bonus_chips}}
end
'''
position = "after"
payload = '''
if specific_vars.bonus_mult then
    localize{type = 'other', key = 'card_extra_mult', nodes = desc_nodes, vars = {specific_vars.bonus_mult}}
end
'''
match_indent = true
times = 1






# Add Virus Functionality -----------------------------------------

    # Apply Virus search in get_flush
[[patches]]
[patches.pattern]
target = "functions/misc_functions.lua"
pattern = '''
function get_flush(hand)
  local ret = {}
  local four_fingers = next(find_joker('Four Fingers'))
  local suits = SMODS.Suit.obj_buffer
  if #hand < (5 - (four_fingers and 1 or 0)) then return ret else
    for j = 1, #suits do
      local t = {}
      local suit = suits[j]
      local flush_count = 0
      for i=1, #hand do
        if hand[i]:is_suit(suit, nil, true) then flush_count = flush_count + 1;  t[#t+1] = hand[i] end 
      end
      if flush_count >= (5 - (four_fingers and 1 or 0)) then
        table.insert(ret, t)
        return ret
      end
    end
    return {}
  end
end
'''
position = "at"
payload = '''
function get_flush(hand)
  local ret = {}
  local four_fingers = next(find_joker('Four Fingers'))
  local suits = SMODS.Suit.obj_buffer
  if #hand < (5 - (four_fingers and 1 or virus and 3 or 0)) then return ret else
    for j = 1, #suits do
      local t = {}
      local suit = suits[j]
      local flush_count = 0
      for i=1, #hand do
        if hand[i]:is_suit(suit, nil, true) then flush_count = flush_count + 1;  t[#t+1] = hand[i] end 
      end
      if flush_count >= (5 - (four_fingers and 1 or (virus and flush_count == #hand) and 3 or 0)) then
        table.insert(ret, t)
        return ret
      end
    end
    return {}
  end
end
'''
match_indent = true
times = 1






# Add Salt Circle Functionality -----------------------------------------

    # Create modifier variable
[[patches]]
[patches.pattern]
target = "game.lua"
pattern = "pack_size = 2,"
position = "after"
payload = "spectrals_used = 0,"
match_indent = true


    # Iterate spectrals_used if spectral card is used_tarot
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if self.ability.consumeable.max_highlighted then
    update_hand_text({immediate = true, nopulse = true, delay = 0}, {mult = 0, chips = 0, level = '', handname = ''})
end
    '''
position = "after"
payload = '''

if self.ability.set == 'Spectral' then
    G.GAME.spectrals_used = G.GAME.spectrals_used + 1
end
'''
match_indent = true
times = 1






# Add Coupon Functionality -----------------------------------------

    # Modify card shop creation
[[patches]]
[patches.pattern]
target = "functions/UI_definitions.lua"
pattern = '''
if polled_rate > check_rate and polled_rate <= check_rate + v.val then
    local card = create_card(v.type, area, nil, nil, nil, nil, nil, 'sho')
'''
position = "at"
payload = '''
if polled_rate > check_rate and polled_rate <= check_rate + v.val then
    local card = create_card(v.type, area, nil, nil, nil, nil, nil, 'sho')
    if card.ability.set == 'Joker' and next(SMODS.find_card('j_mxms_coupon')) and pseudorandom('cou', 1 * G.GAME.probabilities.normal, 30) == 30 then
        card.cost = 0
    end
'''
match_indent = true
times = 1






# Add Power Creep Functionality -----------------------------------------

    # Create modifier variable
[[patches]]
[patches.pattern]
target = "game.lua"
pattern = "pack_size = 2,"
position = "after"
payload = "creep_mod = 1,"
match_indent = true


    # Modify shop costs
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
if self.area and self.ability.couponed and (self.area == G.shop_jokers or self.area == G.shop_booster) then self.cost = 0 end
self.sell_cost_label = self.facing == 'back' and '?' or self.sell_cost
'''
position = "after"
payload = '''
    self.cost = self.cost * G.GAME.creep_mod
'''
match_indent = true
times = 1



    # Modify edition scoring
[[patches]]
[patches.pattern]
target = "card.lua"
pattern = '''
local ret = {card = self}
    if self.edition.x_mult then 
        ret.x_mult_mod = self.edition.x_mult
    end
    if self.edition.mult then 
        ret.mult_mod = self.edition.mult
    end
    if self.edition.chips then 
        ret.chip_mod = self.edition.chips
    end
    return ret
'''
position = "at"
payload = '''
local ret = {card = self}
    if self.edition.x_mult then 
        ret.x_mult_mod = self.edition.x_mult * G.GAME.creep_mod
    end
    if self.edition.mult then 
        ret.mult_mod = self.edition.mult * G.GAME.creep_mod
    end
    if self.edition.chips then 
        ret.chip_mod = self.edition.chips * G.GAME.creep_mod
    end
    return ret
'''
match_indent = true
times = 1






# Add Power Creep Functionality -----------------------------------------

    # Create modifier variable
[[patches]]
[patches.pattern]
target = "game.lua"
pattern = "pack_size = 2,"
position = "after"
payload = "creep_mod = 1,"
match_indent = true






# Add new appearance gates -----------------------------------------

    # Create modifier and tracker variables
[[patches]]
[patches.pattern]
target = "functions/common_events.lua"
pattern = '''
elseif v.enhancement_gate then
    add = nil
    for kk, vv in pairs(G.playing_cards) do
        if SMODS.has_enhancement(vv, v.enhancement_gate) then
            add = true
        end
    end
'''
position = "after"
payload = '''
elseif v.enhancement_gate_set then
    add = nil
    for kk, vv in pairs(G.playing_cards) do
        for kkk, vvv in pairs(v.enhancement_gate_set) do
            if SMODS.has_enhancement(vv, vvv) then
                add = true
            end
        end
    end
elseif v.edition_gate_set then
    add = nil
    for kk, vv in pairs(v.enhancement_gate_set) do
        for kkk, vvv in pairs(G.playing_cards) do
            if SMODS.has_enhancement(vvv, vv) then
                add = true
            end
        end
        for kkk, vvv in pairs(G.jokers) do
            if SMODS.has_enhancement(vvv, vv) then
                add = true
            end
        end
    end
elseif v.seal_gate then
    add = nil
    for kk, vv in pairs(G.playing_cards) do
        if v.seal then
            add = true
        end
    end
elseif v.joker_gate then
    add = nil
    if next(SMODS.find_card(v.joker_gate)) then
        add = true
    end
'''
match_indent = true
times = 1